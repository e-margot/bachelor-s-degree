# -*- coding: utf-8 -*-
"""FINISH VERSION

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z7BfSmZA2-D0rkOemKP_ivlRlWOIAshZ

# Import libraries
"""

# Commented out IPython magic to ensure Python compatibility.
from PIL import Image
import json
import os
import os.path
import torch
import torchvision
from torchvision.transforms import ToTensor, PILToTensor, ConvertImageDtype, Compose
from typing import Any, Callable, Optional, Tuple, List
from torchvision.datasets.vision import VisionDataset
import tarfile
import torch.nn as nn
import numpy as np
import torch.nn.functional as F
import torchvision.datasets as dset
from torchvision.datasets.utils import download_url
from torchvision.datasets import ImageFolder
from torch.utils.data import DataLoader
import torchvision.transforms as tt
from torch.utils.data import random_split
from torchvision.utils import make_grid
import matplotlib.pyplot as plt
import torchvision.models as models
import json
import time
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import copy
import itertools
import argparse
# import pycocotools._mask as maskUtils
from collections import defaultdict
import sys
PYTHON_VERSION = sys.version_info[0]
if PYTHON_VERSION == 2:
    from urllib import urlretrieve
elif PYTHON_VERSION == 3:
    from urllib.request import urlretrieve
# %matplotlib inline
parser = argparse.ArgumentParser(description='Thermal classification')
parser.add_argument('-e', dest='epoch', type=int, default=10, help='Enter number of epoch')
# parser.add_argument('outdir', type=str, help='Output dir for image')
args = parser.parse_args()

"""# Overriding COCO and CocoDetection"""

def _isArrayLike(obj):
    return hasattr(obj, '__iter__') and hasattr(obj, '__len__')


class my_COCO:
    def __init__(self, annotation_file=None):
        """
        Constructor of Microsoft COCO helper class for reading and visualizing annotations.
        :param annotation_file (str): location of annotation file
        :param image_folder (str): location to the folder that hosts images.
        :return:
        """
        # load dataset
        self.dataset,self.anns,self.cats,self.imgs = dict(),dict(),dict(),dict()
        self.imgToAnns, self.catToImgs = defaultdict(list), defaultdict(list)
        if not annotation_file == None:
            print('loading annotations into memory...')
            tic = time.time()
            dataset = json.load(open(annotation_file, 'r'))
            assert type(dataset)==dict, 'annotation file format {} not supported'.format(type(dataset))
            print('Done (t={:0.2f}s)'.format(time.time()- tic))
            self.dataset = dataset
            self.createIndex()

    def createIndex(self):
        # create index
        print('creating index...')
        anns, cats, imgs = {}, {}, {}
        imgToAnns,catToImgs = defaultdict(list),defaultdict(list)
        if 'annotations' in self.dataset:
            for ann in self.dataset['annotations']:
                imgToAnns[ann['id']].append(ann)
                anns[ann['id']] = ann
                # ???
                imgs[ann['id']] = ann


        if 'categories' in self.dataset:
            for cat in self.dataset['categories']:
                cats[cat['id']] = cat

        if 'annotations' in self.dataset and 'categories' in self.dataset:
            for ann in self.dataset['annotations']:
                catToImgs[ann['category_id']].append(ann['id'])

        print('index created!')

        # create class members
        self.anns = anns
        self.imgToAnns = imgToAnns
        self.catToImgs = catToImgs
        self.imgs = imgs
        self.cats = cats

    # def info(self):
    #     """
    #     Print information about the annotation file.
    #     :return:
    #     """
    #     for key, value in self.dataset['info'].items():
    #         print('{}: {}'.format(key, value))


# have a question abot imgs(imgIds)
    def getAnnIds(self, imgIds=[], catIds=[], areaRng=[], iscrowd=None):
        """
        Get ann ids that satisfy given filter conditions. default skips that filter
        :param imgIds  (int array)     : get anns for given imgs
               catIds  (int array)     : get anns for given cats
               areaRng (float array)   : get anns for given area range (e.g. [0 inf])
               iscrowd (boolean)       : get anns for given crowd label (False or True)
        :return: ids (int array)       : integer array of ann ids
        """
        imgIds = imgIds if _isArrayLike(imgIds) else [imgIds]
        catIds = catIds if _isArrayLike(catIds) else [catIds]

        if len(imgIds) == len(catIds) == 0:
            anns = self.dataset['annotations']
        else:
            if not len(imgIds) == 0:
                lists = [self.imgToAnns[imgId] for imgId in imgIds if imgId in self.imgToAnns]
                anns = list(itertools.chain.from_iterable(lists))
            else:
                anns = self.dataset['annotations']
            anns = anns if len(catIds)  == 0 else [ann for ann in anns if ann['category_id'] in catIds]
            # anns = anns if len(areaRng) == 0 else [ann for ann in anns if ann['area'] > areaRng[0] and ann['area'] < areaRng[1]]
        if not iscrowd == None:
            ids = [ann['id'] for ann in anns if ann['iscrowd'] == iscrowd]
        else:
            ids = [ann['id'] for ann in anns]
        return ids

    def getCatIds(self, catNms=[], supNms=[], catIds=[]):
        """
        filtering parameters. default skips that filter.
        :param catNms (str array)  : get cats for given cat names
        :param supNms (str array)  : get cats for given supercategory names
        :param catIds (int array)  : get cats for given cat ids
        :return: ids (int array)   : integer array of cat ids
        """
        catNms = catNms if _isArrayLike(catNms) else [catNms]
        # supNms = supNms if _isArrayLike(supNms) else [supNms]
        catIds = catIds if _isArrayLike(catIds) else [catIds]

        if len(catNms) == len(catIds) == 0:
            cats = self.dataset['categories']
        else:
            cats = self.dataset['categories']
            cats = cats if len(catNms) == 0 else [cat for cat in cats if cat['name']          in catNms]
            cats = cats if len(catIds) == 0 else [cat for cat in cats if cat['id']            in catIds]
        ids = [cat['id'] for cat in cats]
        return ids

    def getImgIds(self, imgIds=[], catIds=[]):
        '''
        Get img ids that satisfy given filter conditions.
        :param imgIds (int array) : get imgs for given ids
        :param catIds (int array) : get imgs with all given cats
        :return: ids (int array)  : integer array of img ids
        '''
        imgIds = imgIds if _isArrayLike(imgIds) else [imgIds]
        catIds = catIds if _isArrayLike(catIds) else [catIds]

        if len(imgIds) == len(catIds) == 0:
            ids = self.imgs.keys()
        else:
            ids = set(imgIds)
            for i, catId in enumerate(catIds):
                if i == 0 and len(ids) == 0:
                    ids = set(self.catToImgs[catId])
                else:
                    ids &= set(self.catToImgs[catId])
        return list(ids)

    def cls(self, ids=[]):
        target = [0] * 80
        a = ([self.anns[id]['category_id'] for id in ids])
        target[a[0] - 1] = 1
        return target
    
    def loadAnns(self, ids=[]):
        """
        Load anns with the specified ids.
        :param ids (int array)       : integer ids specifying anns
        :return: anns (object array) : loaded ann objects
        """
        if _isArrayLike(ids):
            # list_of_targets = [self.cls(ids)]
            # np_of_targets = np.asarray(list_of_targets)
            # return np_of_targets
            # return [self.cls(ids)]
            return self.cls(ids)
            # return print(type([self.anns[id] for id in ids]))
        elif type(ids) == int:
            # print('int')
            return [self.anns[ids]]

    def loadCats(self, ids=[]):
        """
        Load cats with the specified ids.
        :param ids (int array)       : integer ids specifying cats
        :return: cats (object array) : loaded cat objects
        """
        if _isArrayLike(ids):
            return [self.cats[id] for id in ids]
        elif type(ids) == int:
            return [self.cats[ids]]

    def loadImgs(self, ids=[]):
        """
        Load anns with the specified ids.
        :param ids (int array)       : integer ids specifying img
        :return: imgs (object array) : loaded img objects
        """
        if _isArrayLike(ids):
            return [self.imgs[id] for id in ids]
        elif type(ids) == int:
            return [self.imgs[ids]]

    def download(self, tarDir = None, imgIds = [] ):
        '''
        Download COCO images from mscoco.org server.
        :param tarDir (str): COCO results directory name
               imgIds (list): images to be downloaded
        :return:
        '''
        if tarDir is None:
            print('Please specify target directory')
            return -1
        if len(imgIds) == 0:
            imgs = self.imgs.values()
        else:
            imgs = self.loadImgs(imgIds)
        N = len(imgs)
        if not os.path.exists(tarDir):
            os.makedirs(tarDir)
        for i, img in enumerate(imgs):
            tic = time.time()
            fname = os.path.join(tarDir, img['file_name'])
            if not os.path.exists(fname):
                urlretrieve(img['coco_url'], fname)
            print('downloaded {}/{} images (t={:0.1f}s)'.format(i, N, time.time()- tic))

    def loadNumpyAnnotations(self, data):
        """
        Convert result data from a numpy array [Nx7] where each row contains {imageID,x1,y1,w,h,score,class}
        :param  data (numpy.ndarray)
        :return: annotations (python nested list)
        """
        print('Converting ndarray to lists...')
        assert(type(data) == np.ndarray)
        print(data.shape)
        assert(data.shape[1] == 7)
        N = data.shape[0]
        ann = []
        for i in range(N):
            if i % 1000000 == 0:
                print('{}/{}'.format(i,N))
            ann += [{
                'image_id'  : int(data[i, 0]),
                'bbox'  : [ data[i, 1], data[i, 2], data[i, 3], data[i, 4] ],
                'score' : data[i, 5],
                'category_id': int(data[i, 6]),
                }]
        return ann


class aug_my_CocoDetection(VisionDataset):
    """`MS Coco Detection <https://cocodataset.org/#detection-2016>`_ Dataset.

    It requires the `COCO API to be installed <https://github.com/pdollar/coco/tree/master/PythonAPI>`_.

    Args:
        root (string): Root directory where images are downloaded to.
        annFile (string): Path to json annotation file.
        transform (callable, optional): A function/transform that  takes in an PIL image
            and returns a transformed version. E.g, ``transforms.ToTensor``
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        transforms (callable, optional): A function/transform that takes input sample and its target as entry
            and returns a transformed version.
    """

    def __init__(
            self,
            root: str,
            annFile: str,
            transform: Optional[Callable] = None,
            target_transform: Optional[Callable] = None,
            transforms: Optional[Callable] = None,
    ) -> None:
        super().__init__(root, transforms, transform, target_transform)
        from pycocotools.coco import COCO

        self.coco = my_COCO(annFile)
        self.ids = list(sorted(self.coco.imgs.keys()))

    def _load_image(self, id: int) -> Image.Image:
        path = self.coco.loadImgs(id)[0]["file_name"]
        image = Image.open(os.path.join(self.root, os.path.basename(path))).convert('L').resize((256, 256))
        # im_aug = torchvision.transforms.functional.adjust_brightness(image, 0.92)
        # im = torchvision.transforms.functional.invert(im)
        # im_aug = torchvision.transforms.functional.adjust_contrast(im_aug, 2.5)
        im_aug = torchvision.transforms.RandomInvert(p=0.67)(image)
        im_aug = torchvision.transforms.functional.adjust_sharpness(im_aug, 10)
        # image_invert1 = torchvision.transforms.functional.invert(image)
        # image_invert = torchvision.transforms.functional.adjust_brightness(image_invert1, 0.75)
        # image_invert = torchvision.transforms.functional.adjust_contrast(image_invert, 0.8)
        # return Image.open(os.path.join(self.root, os.path.basename(path))).convert('L').resize((256, 256))
        return im_aug
        # return image
    def _load_target(self, id: int):
        return self.coco.loadAnns(self.coco.getAnnIds(id))

    def __getitem__(self, index: int) -> Tuple[Any, Any]:
        id = self.ids[index]
        image = self._load_image(id)
        target = torch.as_tensor(self._load_target(id), dtype=torch.float32)
        if self.transforms is not None:
            image, target = self.transforms(image, target)
        return image, target

    def __len__(self) -> int:
        return len(self.ids)

    def printf(self, id):
        path = self.coco.loadImgs(id)[0]["file_name"]
        im = Image.open(os.path.join(self.root, os.path.basename(path))).convert('L').resize((256, 256))
        # im = Image.open(os.path.join(self.root, os.path.basename(path))).convert('L')
        # im_aug = torchvision.transforms.functional.adjust_brightness(im, 0.92)
        # im = torchvision.transforms.functional.invert(im)
        # im_aug = torchvision.transforms.functional.adjust_contrast(im_aug, 2.5)

        # im_aug = torchvision.transforms.RandomInvert(p=0.3)(im)
        im_aug = torchvision.transforms.functional.adjust_sharpness(im, 15)
        # im_aug.show()

        # im.save("C:/Users/Kirill/Desktop/")
        # im.show()


class my_CocoDetection(VisionDataset):
    """`MS Coco Detection <https://cocodataset.org/#detection-2016>`_ Dataset.

    It requires the `COCO API to be installed <https://github.com/pdollar/coco/tree/master/PythonAPI>`_.

    Args:
        root (string): Root directory where images are downloaded to.
        annFile (string): Path to json annotation file.
        transform (callable, optional): A function/transform that  takes in an PIL image
            and returns a transformed version. E.g, ``transforms.ToTensor``
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        transforms (callable, optional): A function/transform that takes input sample and its target as entry
            and returns a transformed version.
    """

    def __init__(
        self,
        root: str,
        annFile: str,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        transforms: Optional[Callable] = None,
    ) -> None:
        super().__init__(root, transforms, transform, target_transform)
        from pycocotools.coco import COCO

        self.coco = my_COCO(annFile)
        self.ids = list(sorted(self.coco.imgs.keys()))

    def _load_image(self, id: int) -> Image.Image:
        path = self.coco.loadImgs(id)[0]["file_name"]
        # im = Image.open(os.path.join(self.root, os.path.basename(path))).convert("RGB")
        # display(im)
        return Image.open(os.path.join(self.root, os.path.basename(path))).convert('L').resize((256,256))

    def _load_target(self, id: int):
        return self.coco.loadAnns(self.coco.getAnnIds(id))

    def __getitem__(self, index: int) -> Tuple[Any, Any]:
        id = self.ids[index]
        image = self._load_image(id)
        target = torch.as_tensor(self._load_target(id), dtype = torch.float32)
        if self.transforms is not None:
            image, target = self.transforms(image, target)
        return image, target

    def __len__(self) -> int:
        return len(self.ids)
    
    def printf(self, id):
        path = self.coco.loadImgs(id)[0]["file_name"]
        im = Image.open(os.path.join(self.root, os.path.basename(path))).convert("RGB").convert('L').resize((256,256))
        # im = torchvision.transforms.functional.invert(im)
        im.show()

"""# Download dataset"""

transform_rgb = Compose([PILToTensor(),
                         ConvertImageDtype(torch.float),

                     ])
transform_thermal = Compose([PILToTensor(),
                     ConvertImageDtype(torch.float)
                     ])

batch_size = 64

"""TV"""

path2data = "my_FLIR_ADAS_v2/images_rgb_train/new_data"
path2json = "my_FLIR_ADAS_v2/images_rgb_train/ann.json"

coco_TV = aug_my_CocoDetection(path2data, path2json, transform = transform_rgb)
# coco_TV.printf(3522)
coco_loader_TV = DataLoader(coco_TV, batch_size, shuffle=True, num_workers = 0, pin_memory=True)

"""NIR"""

path2data = "my_FLIR_ADAS_v2/images_thermal_val/new_data"
path2json = "my_FLIR_ADAS_v2/images_thermal_val/ann.json"

coco_NIR = my_CocoDetection(path2data, path2json, transform = transform_thermal)
# coco_NIR.printf(10538)
coco_loader_NIR = DataLoader(coco_NIR, batch_size, shuffle=True, num_workers = 0, pin_memory=True)

"""# Override Resnet34
https://www.kaggle.com/code/poonaml/building-resnet34-from-scratch-using-pytorch/notebook
"""

class BasicBlock(nn.Module):
    expansion = 1

    def __init__(self, inplanes, planes, stride=1, downsample=None):
        super().__init__()
        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=3, stride=stride,
                     padding=1, bias=False)
        self.bn1 = nn.BatchNorm2d(planes)
        self.relu = nn.ReLU(inplace=True)
        self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=1,
                     padding=1, bias=False)
        self.bn2 = nn.BatchNorm2d(planes)
        self.downsample = downsample
        self.stride = stride

    def forward(self, x):
        identity = x

        out = self.conv1(x)
        out = self.bn1(out)
        out = self.relu(out)

        out = self.conv2(out)
        out = self.bn2(out)

        if self.downsample is not None:
            identity = self.downsample(x)

        out += identity
        out = self.relu(out)

        return out

def _make_layer(block, inplanes,planes, blocks, stride=1):
    downsample = None  
    if stride != 1 or inplanes != planes:
        downsample = nn.Sequential(            
            nn.Conv2d(inplanes, planes, 1, stride, bias=False),
            nn.BatchNorm2d(planes),
        )
    layers = []
    layers.append(block(inplanes, planes, stride, downsample))
    inplanes = planes
    for _ in range(1, blocks):
        layers.append(block(inplanes, planes))
    return nn.Sequential(*layers)

class ResNet(nn.Module):

    def __init__(self, block, layers, num_classes=80):
        super().__init__()
        
        self.inplanes = 64

        self.conv1 = nn.Conv2d(1, self.inplanes, kernel_size=7, stride=2, padding=3,
                               bias=False)
        self.bn1 = nn.BatchNorm2d(self.inplanes)
        self.relu = nn.ReLU(inplace=True)
        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
        
        self.layer1 = self._make_layer(block, 64, layers[0])
        self.layer2 = self._make_layer(block, 128, layers[1], stride=2)
        self.layer3 = self._make_layer(block, 256, layers[2], stride=2)
        self.layer4 = self._make_layer(block, 512, layers[3], stride=2)
        
        self.avgpool = nn.AdaptiveAvgPool2d((1, 1))
        self.fc = nn.Linear(512 , num_classes)


    def _make_layer(self, block, planes, blocks, stride=1):
        downsample = None  
   
        if stride != 1 or self.inplanes != planes:
            downsample = nn.Sequential(
                nn.Conv2d(self.inplanes, planes, 1, stride, bias=False),
                nn.BatchNorm2d(planes),
            )

        layers = []
        layers.append(block(self.inplanes, planes, stride, downsample))
        
        self.inplanes = planes
        
        for _ in range(1, blocks):
            layers.append(block(self.inplanes, planes))

        return nn.Sequential(*layers)
    
    
    def forward(self, x):
        x = self.conv1(x)           # 224x224
        x = self.bn1(x)
        x = self.relu(x)
        x = self.maxpool(x)         # 112x112

        x = self.layer1(x)          # 56x56
        x = self.layer2(x)          # 28x28
        x = self.layer3(x)          # 14x14
        x = self.layer4(x)          # 7x7

        x = self.avgpool(x)         # 1x1
        x = torch.flatten(x, 1)     # remove 1 X 1 grid and make vector of tensor shape 
        x = self.fc(x)

        return x

def resnet34():
    #layers = [3, 4, 6, 3]
    layers=[2, 2, 2, 2]
    model = ResNet(BasicBlock, layers)
    return model

def get_default_device():
    """Pick GPU if available, else CPU"""
    if torch.cuda.is_available():
        return torch.device('cuda')
    else:
        return torch.device('cpu')
    
def to_device(data, device):
    """Move tensor(s) to chosen device"""
    if isinstance(data, (list,tuple)):
        return [to_device(x, device) for x in data]
    return data.to(device, non_blocking=True)

class DeviceDataLoader():
    """Wrap a dataloader to move data to a device"""
    def __init__(self, dl, device):
        self.dl = dl
        self.device = device
        
    def __iter__(self):
        """Yield a batch of data after moving it to device"""
        for b in self.dl: 
            yield to_device(b, self.device)

    def __len__(self):
        """Number of batches"""
        return len(self.dl)

device = get_default_device()
print(device)

def accuracy(outputs, labels):
    # _, preds = torch.max(outputs, dim=1)
    # return torch.tensor(torch.sum(preds == labels).item() / len(preds))
    _, preds = torch.max(outputs, dim=1)
    _, targs = torch.max(labels, dim=1)
    # print(preds)
    # print(targs)
    return torch.tensor(torch.sum(preds == targs).item() / len(preds))


class ImageClassificationBase(nn.Module):
    def training_step(self, batch):
        images, labels = batch 
        out = self(images)                  # Generate predictions
        loss = F.cross_entropy(out, labels) # Calculate loss
        return loss
    # rewrite
    def validation_step(self, batch):
        images, labels = batch
        out = self(images)                    # Generate predictions
        labels1 = labels.softmax(dim=1)
        # print(labels, labels.size())
        # print(labels)
        # print(out)
        # print (out, out.size())
        loss = F.cross_entropy(out, labels1)   # Calculate loss
        acc = accuracy(out, labels)           # Calculate accuracy
      
        return {'val_loss': loss.detach(), 'val_acc': acc}
        
    def validation_epoch_end(self, outputs):
        batch_losses = [x['val_loss'] for x in outputs]
        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses
        batch_accs = [x['val_acc'] for x in outputs]
        epoch_acc = torch.stack(batch_accs).mean()      # Combine accuracies
        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}
    
    def epoch_end(self, epoch, result):
        print("Epoch [{}], train_loss: {:.4f}, val_loss: {:.4f}, val_acc: {:.4f}".format(
            epoch, result['train_loss'], result['val_loss'], result['val_acc']))

coco_loader_NIR = DeviceDataLoader(coco_loader_NIR, device)
coco_loader_TV = DeviceDataLoader(coco_loader_TV, device)

resnet34_debug = resnet34()


# resnet34 = models.resnet34()
# resnet34

class FLIR80Resnet(ImageClassificationBase):
        def __init__(self):
                super().__init__()
                self.network = resnet34()
                # self.network = torchvision.models.resnet34()
                num_ftrs = self.network.fc.in_features
                self.network.fc = nn.Linear(num_ftrs, 80)
        
        def forward(self, xb):
                return self.network(xb)
            
model = FLIR80Resnet()

model = model.to('cuda')
# model = to_device(FLIR80Resnet(), device)

@torch.no_grad()
def evaluate(model, val_loader):
    model.eval()
    # outputs = [model.validation_step(batch) for batch in val_loader]
    outputs2 = []
    i = 0
    for batch in val_loader:
      # print(i)
      i+=1
      outputs2.append(model.validation_step(batch))
    return model.validation_epoch_end(outputs2)

def fit(epochs, lr, model, train_loader, val_loader, 
        weight_decay=0, opt_func=torch.optim.SGD):
    history = []
    model.load_state_dict(torch.load('weights/model.pth'))
    optimizer = opt_func(model.parameters(), lr, weight_decay=weight_decay)
    for epoch in range(epochs):
        # Training Phase 
        model.train()
        train_losses = []
        for batch in train_loader:
            loss = model.training_step(batch)
            train_losses.append(loss)
            loss.backward()
            optimizer.step()
            optimizer.zero_grad()
        # Validation phase
        result = evaluate(model, val_loader)
        result['train_loss'] = torch.stack(train_losses).mean().item()
        model.epoch_end(epoch, result)
        history.append(result)
        torch.save(model.state_dict(), 'weights/model.pth')
    return history

# history = [evaluate(model, coco_loader_TV)]

# For this model we gonna use Adam Optimization
opt_func = torch.optim.Adam

train_dl = coco_loader_TV
valid_dl = coco_loader_NIR
epoch = args.epoch
# history1 = fit(8, 1e-3, model, train_dl, valid_dl, 5e-4, opt_func)

# history2 = fit(10, 1e-5, model, train_dl, valid_dl, 5e-4, opt_func)
# 1e-4
history3 = fit(epoch, 1e-4, model, train_dl, valid_dl, 5e-4, opt_func)

# history4 = fit(15, 1e-2, model, train_dl, valid_dl, 5e-4, opt_func)

# history = fit(25, 1e-5, model, train_dl, valid_dl, 5e-4, opt_func)

def plot_accuracies(history, fname):
    accuracies = [x['val_acc'] for x in history]
    plt.plot(accuracies, '-x')
    plt.xlabel('epoch')
    plt.ylabel('accuracy')
    plt.title('Accuracy vs. No. of epochs')
    # fname = 'accuracy.jpg'
    plt.savefig(fname)
#
fname1 = 'accuracy1.jpg'
fname2 = 'accuracy2.jpg'
fname3 = 'accuracy3.jpg'
fname4 = 'accuracy4.jpg'
# plot_accuracies(history1, fname1)
# plot_accuracies(history2, fname2)
# plot_accuracies(history3, fname3)
# plot_accuracies(history4, fname4)

def plot_losses(history, fname):
    train_losses = [x.get('train_loss') for x in history]
    val_losses = [x['val_loss'] for x in history]
    plt.xlabel('epoch')
    plt.ylabel('loss')
    plt.title('Loss vs. No. of epochs')
    # fname = 'loss_func.jpg'
    plt.savefig(fname)



fname1 = 'loss_func1.jpg'
fname2 = 'loss_func2.jpg'
fname3 = 'loss_func3.jpg'
fname4 = 'loss_func4.jpg'
# plot_losses(history1, fname1)
# plot_losses(history2, fname2)
# plot_losses(history3, fname3)
# plot_losses(history4, fname4)