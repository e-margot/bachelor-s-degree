# -*- coding: utf-8 -*-
"""FINISH VERSION

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z7BfSmZA2-D0rkOemKP_ivlRlWOIAshZ

# Import libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import torch
from torchvision.transforms import ToTensor, PILToTensor, ConvertImageDtype, Compose
import torch.nn as nn
from torch.utils.data import DataLoader
import matplotlib.pyplot as plt
import argparse

from my_coco_collection import MyCocoDetection
from resnet import ResNet, BasicBlock
from image_classificaton_base import ImageClassificationBase
from augmentate_coco import AugMyCocoDetection
"""# Override Resnet34
https://www.kaggle.com/code/poonaml/building-resnet34-from-scratch-using-pytorch/notebook
"""


def resnet34():
    layers = [2, 2, 2, 2]
    model_instance = ResNet(BasicBlock, layers)
    return model_instance


def get_default_device():
    """Pick GPU if available, else CPU"""
    if torch.cuda.is_available():
        return torch.device('cuda')
    else:
        return torch.device('cpu')


def to_device(data, device):
    """Move tensor(s) to chosen device"""
    if isinstance(data, (list, tuple)):
        return [to_device(x, device) for x in data]
    return data.to(device, non_blocking=True)


class DeviceDataLoader:
    """Wrap a dataloader to move data to a device"""

    def __init__(self, dl, device):
        self.dl = dl
        self.device = device

    def __iter__(self):
        """Yield a batch of data after moving it to device"""
        for b in self.dl:
            yield to_device(b, self.device)

    def __len__(self):
        """Number of batches"""
        return len(self.dl)


class FLIR80Resnet(ImageClassificationBase):
    def __init__(self):
        super().__init__()
        self.network = resnet34()
        num_ftrs = self.network.fc.in_features
        self.network.fc = nn.Linear(num_ftrs, 80)

    def forward(self, xb):
        return self.network(xb)


@torch.no_grad()
def evaluate(this_model, val_loader):
    this_model.eval()
    outputs2 = []
    for batch in val_loader:
        outputs2.append(this_model.validation_step(batch))
    return this_model.validation_epoch_end(outputs2)


def fit(epochs, lr, this_model, train_loader, val_loader,
        weight_decay=0, this_opt_func=torch.optim.SGD):
    loss_history = []
    this_model.load_state_dict(torch.load('weights/model.pth'))
    optimizer = this_opt_func(this_model.parameters(), lr, weight_decay=weight_decay)
    for epoch in range(epochs):
        # Training Phase 
        this_model.train()
        train_losses = []
        for batch in train_loader:
            loss = this_model.training_step(batch)
            train_losses.append(loss)
            loss.backward()
            optimizer.step()
            optimizer.zero_grad()
        # Validation phase
        result = evaluate(this_model, val_loader)
        result['train_loss'] = torch.stack(train_losses).mean().item()
        this_model.epoch_end(epoch, result)
        loss_history.append(result)
        torch.save(this_model.state_dict(), 'weights/model.pth')
    return loss_history


def plot_accuracies(acc_history, file_name):
    accuracies = [x['val_acc'] for x in acc_history]
    plt.plot(accuracies, '-x')
    plt.xlabel('epoch')
    plt.ylabel('accuracy')
    plt.title('Accuracy vs. No. of epochs')
    plt.savefig(file_name)


#

def plot_losses(loss_history, file_name):
    train_losses = [x.get('train_loss') for x in loss_history]
    val_losses = [x['val_loss'] for x in loss_history]
    plt.xlabel('epoch')
    plt.ylabel('loss')
    plt.title('Loss vs. No. of epochs')
    plt.savefig(file_name)


losses_names = {
    1: 'loss_func1.jpg',
    2: 'loss_func2.jpg',
    3: 'loss_func3.jpg',
    4: 'loss_func4.jpg',
}

accuracy_names = {
    1: 'accuracy1.jpg',
    2: 'accuracy2.jpg',
    3: 'accuracy3.jpg',
    4: 'accuracy4.jpg',
}

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Thermal classification')
    parser.add_argument('-e', dest='epoch', type=int, default=10, help='Enter number of epoch')
    args = parser.parse_args()

    """# Download dataset"""

    transform_rgb = Compose([PILToTensor(),
                             ConvertImageDtype(torch.float),

                             ])
    transform_thermal = Compose([PILToTensor(),
                                 ConvertImageDtype(torch.float)
                                 ])

    batch_size = 64

    """TV"""

    path2data = "my_FLIR_ADAS_v2/images_rgb_train/new_data"
    path2json = "my_FLIR_ADAS_v2/images_rgb_train/ann.json"

    coco_TV = AugMyCocoDetection(path2data, path2json, transform=transform_rgb)
    coco_loader_TV = DataLoader(coco_TV, batch_size, shuffle=True, num_workers=0, pin_memory=True)

    """NIR"""

    path2data = "my_FLIR_ADAS_v2/images_thermal_val/new_data"
    path2json = "my_FLIR_ADAS_v2/images_thermal_val/ann.json"

    coco_NIR = MyCocoDetection(path2data, path2json, transform=transform_thermal)
    coco_loader_NIR = DataLoader(coco_NIR, batch_size, shuffle=True, num_workers=0, pin_memory=True)

    device = get_default_device()
    print(device)

    coco_loader_NIR = DeviceDataLoader(coco_loader_NIR, device)
    coco_loader_TV = DeviceDataLoader(coco_loader_TV, device)

    resnet34_debug = resnet34()

    model = FLIR80Resnet()

    model = model.to('cuda')

    # For this model we gonna use Adam Optimization
    opt_func = torch.optim.Adam

    train_dl = coco_loader_TV
    valid_dl = coco_loader_NIR
    epoch = args.epoch

    training_cycles = {
        1: [8, 1e-3, model, train_dl, valid_dl, 5e-4, opt_func],
        2: [10, 1e-5, model, train_dl, valid_dl, 5e-4, opt_func],
        3: [epoch, 1e-4, model, train_dl, valid_dl, 5e-4, opt_func],
        4: [15, 1e-2, model, train_dl, valid_dl, 5e-4, opt_func],
        5: [25, 1e-5, model, train_dl, valid_dl, 5e-4, opt_func]
    }

    INDEX = 3

    history = fit(*training_cycles[INDEX])
    plot_accuracies(history, accuracy_names[INDEX])
    plot_losses(history, losses_names[INDEX])
